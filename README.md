# Установка
Установка с помощью пакетных менеджеров не предусмотрена. Следует просто клонировать репозиторий.

`git clone https://github.com/OneAdder/Old-Russian-dictionaries`

# Запуск
Для запуска веб-приложения следует третьим Питоном запустить `old_rus_dictionaries.py`

Зависимости: `Flask`, `cython3`.



Для запуска обработки словарей следут запустить Башем скрипт `data_processing/match.sh` (пользователи Windows могут запустить Питоном скрипты по порядку: `data_processing/tei_parser.py`, `data_processing/matcher.py` и `data_processing/finish_match.py`). Результаты выведутся в файл `data_processing/matched.json`.

Зависимости: `cython3`, `pandas`, `bs4`.

# Устройство данных
Устройство JSON-файла `data_processing/matched.json`


```
{
    унифицированная_лемма (str):
     {
        "avanesov_lemma": XI-XIV_лемма (str),
        "avanesov_data": {
        "gramGrp": граматический_клас (str),
        "definition": определение (str),
        "usg": использование (str),
        "inflected": изменяемый/неизменяемый (bool),
        "examples": 
        [
            {
                "example": пример (str),
                "src": источник (str)
            },
            ...
        ],
        "inflection": {формы (dict)}
        },
        "XVII_lemma": XI-XVII_лемма,
        "XVII_lemma_index": ещё_одна_лемма_из_того_же_словаря
    },
   ...
}
```

# Библиотека unification
Мы создали библиотеку `data_processing/unification.pyx`. 
Для работы с библиотекой требуется установить пакет `cython3`. Далее её можно импортировать следующим образом:
```
import pyximport; pyximport.install()
import unification
```
Эта библиотека на языке Cython содержит ряд полезных для работы с древнерусскими вариантами написания функций.

unification.**unify** принимает слово `str` и приводит его к единому формату. Таким образом, можно сравнить два слова: если они одинаковые (например, "вседержитель" и "вьседержитель"), то `unify` выдаст один результат для обоих слов.  
```
>>> unify('вьседержителъ')
'въсєдєръжитєлъ'
>>> unify('всєдєржитєль')
'въсєдєръжитєлъ'
```

unification.**all_options** принимает слово `str` и выводит все способы перевода в унифицированную графику, учитывая разнообразие способов постановки редуцированных. 
```
>>> all_options('мълъва')
('молъва', 'мълъва', 'молъва')
```
Данная функцию нужна, так как не всегда можно предугадать все возможные позиции редуцированных (`unify` лишь даёт наиболее вероятный вариант).  
Пока не найдено нормальное слово, где это может пригодиться, так что пример ниже искуственный. Как видно функция `unify` выдаёт разные варианты для слов, которые требуется сметчить, в том время как `all_options` выдаёт кортеж, который содержит вариант, введённый во втором вызове функции `unify`, а также вывод обоих вызовов этой функции.  
Этот даёт возможность сметчить варианты "тъттъ", "тотътъ", "тътътъ" и "тътотъ".
```
>>> unify('тъттъ')
'тотътъ'
>>> unify('тътътъ')
'тътотъ'
>>> all_options('тъттъ')
('тотътъ', 'тътътъ', 'тътотъ')
```

unification.**compare** принимает два слова `str`, сравнивает, если формы одинаковые, то возвращает унифицированную форму, совместимую с выводом функции `unify`. Если слова нужно сметчить, то функция возвращает слово в унифицированном виде. Если слова разные, функция не возвращает ничего.  
Данная функция так же поддерживает расширенную проверку позиций редуцированных.
```
>>> compare('вьседержителъ', 'всєдєржитєль')
'въсєдєръжитєлъ'
>>> compare('тътътъ', 'тътотъ')
'тътотъ'
>>> compare('тътътъ', 'тъттъ')
'тътотъ'
```

## Алгоритм унификации
### Алгоритм сделан на основе статей:
* "Автоматический морфологический анализатор древнерусского языка: лингвистические и технологические решения"
Баранов, Миронов, Лапин, Мельникова, Соколова, Корепанова.

* "ВЗIAЛЪ, ВЪЗЯЛЪ, ВЬЗЯЛ: ОБРАБОТКА ОРФОГРАФИЧЕСКОЙ ВАРИАТИВНОСТИ ПРИ ЛЕКСИКО-ГРАММАТИЧЕСКОЙ АННОТАЦИИ СТАРОРУССКОГО КОРПУСА XV–XVII ВВ." Т. С. Г АВРИЛОВА, Т. А. ШАЛГАНОВА, О. Н. ЛЯШЕВСКАЯ.

### Порядок действий
1. Привести к нижнему регистру, удалить лишние знаки и т.д.
2. Привести равнозначные знаки и фонологически незначимые отличия к единой форме. Подробнее см. докстринги `unify_various_symbols`.
3. Привести конечный редуцированный в "ъ".
4. Уменьшить разнообразие гласные после после шипящих. Подробнее см. докстринги `unify_vowels_after_set1`.
5. Дезйотировать гласные в позиции начала слова и после гласных. Подробнее см. докстринги unify_iotated
6. Перевести "ь" после йотированных гласных и "i" в "и".
7. Преобразовать ряд сочетаний плавных с гласными. Подробнее см. докстринги `unify_r_and_l_with_shwas1`, `unify_r_and_l_with_shwas2` и `unify_r_and_l_with_yat`.
8. Эмулировать падение редуцированных.
9. Добавить принцип открытого слога.

Последние два пункта используются в функции `unify`. В функциях `compare` и `all_options` используется растроение возможного положения редуцированных. Сравнивается слово, полученное пунктами 1-7.
В слове проставляются редуцированные тремя способами:
1. Редуцированные упали/прояснились, "ъ" возник по принципу открытого слога.
2. "ъ" возник по принципу открытого слога.
4. "ъ" возник по принципу открытого слога, редуцированные упали/прояснились, "ъ" возник по принципу открытого слога.

Как видно первый вариант является стандартным алгоритмом и результат его работы совпадает с выводом функции `unify`. Остальные два варианта отличаются.

# Скрипт для обработки данных
Скрипт match.sh обрабатывает все имеющиеся данные и приводит в matched.json. Данный Bash-скрипт запускает скрипты на языке Python3. Порядок следующий:
1. `tei_parser.py`: парсит словарь Аванесова в формате `TEI` и сохраняет в `avanesov2.json`.
2. `matcher.py`: проходится по словарю Аванесова и ищет аналоги из словаря XI-XVII. Импортирует модули `match_cython` и `unification`, написанные на Cython. Сохраняет результат в `prematched.json`.
3. `finish_match.py`: вставляет данные из словаря XI-XVII, для которых не нашлось соответствий в словаре Аванесова, и сохраняет результат в `matched.json`.

# Использование
Данный код свободно распространяется под лицензией GNU GPLv3. Это значит, что вы можете свободно его использовать при условии, что оставите его открытым и упомяните его авторов.
Если вы собираетесь использовать его в научных публикациях, нам будет приятно, если вы упомяните нас так же в благодарностях.
Скорее всего, мы так же будем заинтересованы принять участие.
